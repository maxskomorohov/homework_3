
Обчисливши різні діапазони чисел, було отримано наступні результати.

    # 1'000 (2 threads)
        # Функція find_primes_single_thread виконується за 0.000100 секунд
        # Функція find_primes_multi_thread виконується за 0.0002 секунд
        # Функція find_primes_asyncio виконується за 0.0002 секунд

    # 1'000'000 (2 threads)
        # Функція find_primes_single_thread виконується за 0.714913 секунд
        # Функція find_primes_multi_thread виконується за 0.7013 секунд
        # Функція find_primes_asyncio виконується за 0.6988 секунд

    # 10'000'000 (2 threads)
        # Функція find_primes_single_thread виконується за 19.235863 секунд
        # Функція find_primes_multi_thread виконується за 19.0615 секунд
        # Функція find_primes_asyncio виконується за 19.0642 секунд

    # 10'000'000 (10 threads)
        # Функція find_primes_single_thread виконується за 19.179566 секунд
        # Функція find_primes_multi_thread виконується за 18.9957 секунд
        # Функція find_primes_asyncio виконується за 19.2379 секунд


Мої виводи наступні:
    * Великої різниці між роботою функцій нема навіть на діапазоні в 10 млн значень. Я вважаю, що це пов'язано
    саме з простими обрахунками, тобто (операцій які можуть бути виконані без затримок - нема ані вводу/виводу,
    очікування відповіді сервера, часу роботи БД тощо.

    * На невеликому діапазоні асинхронні та багатопоточні операції навіть програють одному потоку через те, що
    певний час втрачається на створення та керування потоками.

    * Функція ділення діапазону на рівномірні відрізки майже не займає часу на виконання, тому її можна не
    враховувати (0.00001).

    * Я не впевнений в тому, що виграш декількох мілісекунд на великих дівпазонах, пов'язаний саме з багатопоточністю,
     а не з завантаженням ядер або якимись іншими фоновими процесами комп'ютера.

    * Багатопоточність / асинхронність однозначно дає виграш там де час втрачається на очікуванні (I/O операції,
    bandwidth та завантаження файлів, затримки відповіді сервера або БД).

    * Однопоточність може бути ефективною для фонової обробки даних, де немає необхідності в паралельному виконанні,
    (наприклад, для обробки великих обсягів даних або виконання обчислень, що не потребують взаємодії з зовнішніми
    ресурсами).